								String

1. Creating a string
irb(main):089:0> s= String.new("hello world!!",encoding:'UTF-8',capacity:10)
=> "hello world!!"

2. Format Strings
irb(main):095:0> "%0f"% 1234
=> "1234.000000"
irb(main):096:0> "%0s"% 1234
=> "1234"
irb(main):097:0> "%0c"% 1234
=> "Ӓ"
irb(main):098:0> "%0c"% 97
=> "a"
irb(main):099:0> "%0x"% 97
=> "61"
irb(main):100:0> "%0"% 97
Traceback (most recent call last):
        5: from /usr/bin/irb:23:in `<main>'
        4: from /usr/bin/irb:23:in `load'
        3: from /usr/lib/ruby/gems/2.7.0/gems/irb-1.2.6/exe/irb:11:in `<top (required)>'
        2: from (irb):100
        1: from (irb):100:in `%'
ArgumentError (invalid format character - %)
irb(main):101:0> "%0o"% 97
=> "141"
irb(main):102:0> "%o"% 97
=> "141"
irb(main):103:0> "%b"% 97
=> "1100001"
irb(main):104:0> 

string % object
irb(main):115:0> "%-5s : %016x" % ["ID", self.object_id]
=> "ID    : 0000000000003444"
irb(main):116:0> "foo = %{foo}" % {foo: 'bar'}
=> "foo = bar"
irb(main):117:0> "foo = %{foo}, baz = %{baz}" % {foo: 'bar',baz:'bat'}
=> "foo = bar, baz = bat"

string * integer
irb(main):120:0> "Ruby!!!" * 3
=> "Ruby!!!Ruby!!!Ruby!!!"
irb(main):121:0> "Ruby!!!" * 0
=> ""

irb(main):127:0> "Hello Ruby " + self.to_s
=> "Hello Ruby main"

3. Regex with strings

irb(main):195:0> 'hello there'[/[aeiou](.)\l/,0]
=> "ell"
irb(main):196:0> 'hello there'[/[aeiou](.)\l/,1]
=> "l"
irb(main):197:0> 'hello there'[/[aeiou](.)\l/,2]
=> nil
irb(main):198:0> 'hello there'[/[aeiou](.)\l/,0]
=> "ell"

irb(main):203:0> 'hello there'[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/,"non_vowel"]
=> "l"
irb(main):204:0> 'hello there'[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/,:vowel]
=> "e"
irb(main):205:0> 'hello there'[/(?<vowel>[aeiou](.))(?<non_vowel>[^aeiou])/,:vowel]
=> "el"
irb(main):206:0> 'hello there'[/(?<vowel>[aeiou](..))(?<non_vowel>[^aeiou])/,:vowel]
=> "o t"

Slice
irb(main):210:0> 'hello there'.slice(0)
=> "h"
irb(main):211:0> 'hello there'.slice(0,3)
=> "hel"
irb(main):212:0> 'hello there'.slice(0..3)
=> "hell"

4. Bytes,b,bytesize,byteslice

irb(main):313:0> s= "\x80\u3042"
=> "\x80あ"
irb(main):314:0> s.slice(1)
=> "あ"
irb(main):315:0> s.size
=> 2
irb(main):316:0> s.bytesize
=> 4

irb(main):348:0> s.byteslice(1..1)
=> "\xE3"
irb(main):349:0> s
=> "\x80\xE3\x81\x82"
irb(main):350:0> str
=> "\x80あ"
irb(main):351:0> str.byteslice(1..1)
=> "\xE3"
irb(main):352:0> str.byteslice(1..2)
=> "\xE3\x81"

Capatalize
irb(main):363:0> s = "abcd234Anb"
=> "abcd234Anb"
irb(main):364:0> s.capitalize
=> "Abcd234anb"
irb(main):365:0> s
=> "abcd234Anb"
irb(main):366:0> s.capitalize!
=> "Abcd234anb"
irb(main):367:0> s
=> "Abcd234anb"
irb(main):368:0> s.downcase
=> "abcd234anb"
irb(main):369:0> s
=> "Abcd234anb"
irb(main):370:0> s.downcase!
=> "abcd234anb"

casecmp with ignorinig case 
irb(main):373:0> 'foo'.casecmp('Foo')
=> 0
irb(main):374:0> 'foo'.casecmp('Food')
=> -1
irb(main):375:0> 'foode'.casecmp('Food')
=> 1
irb(main):376:0> 'fooe'.casecmp('Food')
=> 1
irb(main):377:0> 'fooa'.casecmp('Food')
=> -1

irb(main):378:0> 'fooa'.casecmp?('Food')
=> false
irb(main):379:0> 'food'.casecmp?('Food')
=> true

center a string 
irb(main):393:0> s= 'good'.center(9,">")
=> ">>good>>>"

irb(main):384:0> s= 'good'.center(8)
=> "  good  "
irb(main):385:0> s
=> "  good  "
irb(main):386:0> s.length
=> 8
irb(main):387:0> s= 'good'.center(4)
=> "good"
irb(main):388:0> s.length
=> 4

chars to convert str to array
irb(main):396:0> s
=> ">>good>>>"
irb(main):397:0> sary = s.chars
=> [">", ">", "g", "o", "o", "d", ">", ">", ">"]
irb(main):399:0> sary.count
=> 9
irb(main):400:0> s.each_char.to_a
=> [">", ">", "g", "o", "o", "d", ">", ">", ">"]

chomp removes /r,/n and /r/n or given record seperator if present from the end of string

irb(main):440:0> s= "hello\r\r\n".chomp
=> "hello\r"
irb(main):441:0> s= "hello\r\n".chomp
=> "hello"
irb(main):442:0> s= "hello\r\n\rn".chomp
=> "hello\r\n\rn"
irb(main):443:0> s= "hello\r\n\r".chomp
=> "hello\r\n"

chop 
irb(main):484:0> s= "hello x abcd".chop
=> "hello x abc"
irb(main):485:0> s= "hello x abcd".chop.chop.chop
=> "hello x a"
irb(main):486:0> s= "hello x abcd\n\r".chop.chop.chop
=> "hello x abc"
irb(main):487:0> s= "hello x abcd\n\r\n".chop.chop.chop
=> "hello x abc"
irb(main):488:0> s= "hello x abcd\n\r\n\r\n\n\r".chop.chop.chop
=> "hello x abcd\n\r\n"

irb(main):491:0> s = "ab3.kd993,9.2.ab1"
=> "ab3.kd993,9.2.ab1"
irb(main):492:0> s.codepoints
=> [97, 98, 51, 46, 107, 100, 57, 57, 51, 44, 57, 46, 50, 46, 97, 98, 49]
irb(main):493:0> s.each_codepoint.to_a
=> [97, 98, 51, 46, 107, 100, 57, 57, 51, 44, 57, 46, 50, 46, 97, 98, 49]

count function return integer according to set of characters found
irb(main):534:0> s = "hello^worl*d"
=> "hello^worl*d"
irb(main):535:0> s.count "*"
=> 1
irb(main):536:0> s.count "\*"
=> 1
irb(main):537:0> s.count "^*"
=> 11
irb(main):538:0> s.count "\^*"
=> 11
irb(main):539:0> s.count "\\^*"
=> 2


